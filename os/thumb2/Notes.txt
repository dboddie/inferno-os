Remove everything from the mkfile except the core sources.
Create mem.h, fns.h, io.h, dat.h, fpi.h files.
Comment out JIT code in libinterp.
mkdir Inferno/thumb/lib
Add void systick(void) to the fns.h and clock.c files.
Ensure that the correct linker is used.
Try to compile the sources and start adding functions to fix missing symbols.
Fix the linker to get it to handle missing operations, though it's strange that
the double precision operations should cause problems and need to be explicitly
included in the optab.


Problems with ilock turned out to be problems in todsetfreq, called from
todinit, that calls mk64fract which performs a division on one of its arguments
that triggers a division by zero in dodiv (in libkern/vlrt-thumb.c) called via
_divvu (also in vlrt-thumb.c).

The incorrect value is held in tod.hz (in port/tod.c) when todinit calls
todsetfreq with the existing value of tod.hz, which is zero at that point.
Experimenting with the A7000+ port, it seems that tod.hz is set to the value
defined as HZ in the mem.h file. It appears that the fastticks function (in
clock.c) needs to assign the value of HZ to the contents of the address it
receives.


Writing a function to implement serwrite using the USART leads to an assertion
in (port/devcons.c), but at least it wrote it to the USART. Actually, it looks
like the assert is not due to the serwrite function but just something that
happens to be visible because there is a function to print it. The assertion is
actually in the tadd function in port/portclock.c.

Implementing a UART device interface like the miniuart in the rpi port.


The "arena too large" error is temporarily solved by tuning the pool allocation
table in port/alloc.c to select chunk sizes that are large enough.


Spent a lot of time trying to find out what was corrupting the pool->root->left
members in port/alloc.c only to find that the setmalloctag function was doing
it. Disabled tracing in that file.

The source of unaligned accesses related to locks occur in port/chan.c in the
newcname function when smalloc is called, returning a non-word-aligned address.
Since the Cname struct is based on the Ref struct and the incref function
relies on the Ref members to perform locking, the resulting address passed via
lock to _tas causes the unaligned access.

Found that the namec function in port/chan.c corrupts the pool structure when
assigning the aname argument to the name variable.

(Spent some time trying to determine if preemption was causing stack issues and
fixing interrupt handling.)

It turns out that the amount of stack allocated per-process was too small and
the stack was overrunning into adjacent pool blocks. I updated the KSTKSIZE
definition in mem.h to 512 bytes.


Booting gets as far as the message, '[Init] Broken: "module not loaded"'. The
module that fails is the init module at "/osinit.dis", which should be there.
The problem was the missing "sys" entry in the "mod" section of the conf file.

A simple init script can print a welcome message.


Trying to spawn a shell causes the init process to hang or, at least, not print
the welcome message.


Revisiting process context switching, the sched() function is called when
schedinit() is called by the main() function. This causes the init0() function
to be run, which enables interrupts. This allows the systick handler to
interrupt processes.

When a process (P) is interrupted by the systick interrupt, the processor is
put into handler mode with automatically stacked registers and a special value
of R14 (EXC_RETURN) that will be used to exit handler mode. The interrupt
handler calls a C function that calls the preemption() function. If preemption
should occur, this function calls sched() to switch to another process (Q),
updating the PC and SP:

    Process P running -> Interrupt handler -> systick() -> sched()
                                                                  \
                                                            PC and SP updated
                                                                  /
    Process Q running <- Interrupt handler <- systick() <- sched()

The other process should have reached sched() in the same way, so it will
return from the sched() function all the way back to the interrupt handler
using its own stack. The handler returns normally, putting the EXC_RETURN value
into the PC and the processor switches back to thread mode and continues
executing process Q.

One problem is that the sched() function is called in normal thread mode when
schedinit() is called, without having switched to handler mode. It also does so
without all the additional frames and extra data on the stack, but this is not
a problem because the stack is switched when the process is switched, so the
program would not be encountering code in the trap file with incorrect stack
frames. Also, returning to the first label in schedinit() causes sched() to be
called again. This shouldn't be a problem if another process is entered as long
as that process was previously entered via the interrupt handler. Otherwise,
the processor remains in handler mode.
