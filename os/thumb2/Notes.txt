Remove everything from the mkfile except the core sources.
Create mem.h, fns.h, io.h, dat.h, fpi.h files.
Comment out JIT code in libinterp.
mkdir Inferno/thumb/lib
Add void systick(void) to the fns.h and clock.c files.
Ensure that the correct linker is used.
Try to compile the sources and start adding functions to fix missing symbols.
Fix the linker to get it to handle missing operations, though it's strange that
the double precision operations should cause problems and need to be explicitly
included in the optab.


Problems with ilock turned out to be problems in todsetfreq, called from
todinit, that calls mk64fract which performs a division on one of its arguments
that triggers a division by zero in dodiv (in libkern/vlrt-thumb.c) called via
_divvu (also in vlrt-thumb.c).

The incorrect value is held in tod.hz (in port/tod.c) when todinit calls
todsetfreq with the existing value of tod.hz, which is zero at that point.
Experimenting with the A7000+ port, it seems that tod.hz is set to the value
defined as HZ in the mem.h file. It appears that the fastticks function (in
clock.c) needs to assign the value of HZ to the contents of the address it
receives.


Writing a function to implement serwrite using the USART leads to an assertion
in (port/devcons.c), but at least it wrote it to the USART. Actually, it looks
like the assert is not due to the serwrite function but just something that
happens to be visible because there is a function to print it. The assertion is
actually in the tadd function in port/portclock.c.

Implementing a UART device interface like the miniuart in the rpi port.


The "arena too large" error is temporarily solved by tuning the pool allocation
table in port/alloc.c to select chunk sizes that are large enough.


Spent a lot of time trying to find out what was corrupting the pool->root->left
members in port/alloc.c only to find that the setmalloctag function was doing
it. Disabled tracing in that file.

The source of unaligned accesses related to locks occur in port/chan.c in the
newcname function when smalloc is called, returning a non-word-aligned address.
Since the Cname struct is based on the Ref struct and the incref function
relies on the Ref members to perform locking, the resulting address passed via
lock to _tas causes the unaligned access.

Found that the namec function in port/chan.c corrupts the pool structure when
assigning the aname argument to the name variable.

(Spent some time trying to determine if preemption was causing stack issues and
fixing interrupt handling.)

It turns out that the amount of stack allocated per-process was too small and
the stack was overrunning into adjacent pool blocks. I updated the KSTKSIZE
definition in mem.h to 512 bytes.


Booting gets as far as the message, '[Init] Broken: "module not loaded"'. The
module that fails is the init module at "/osinit.dis", which should be there.
The problem was the missing "sys" entry in the "mod" section of the conf file.
